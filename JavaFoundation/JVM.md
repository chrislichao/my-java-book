# JVM
##### 1，JVM的三个子系统
- 类加载子系统：根据程序运行的需要加载用到的类
- 执行引擎子系统：在JVM种执行字节码指令
- 垃圾收集子系统：自动内存管理
##### 2，JVM运行时数据区（内存模型）
- 方法区
  - 存放：运行时常量池信息，静态变量的引用，类信息
  - 1.8前被称作永久代
  - 1.8及1.8后称为元空间（使用操作系统的直接内存）
- 虚拟机栈（JAVA栈，线程栈）
  - 是线程私有的，声明周期与线程相同，虚拟机栈是Java方法执行的内存模型，每个方法被执行时都会创建一个栈帧，即方法运行期间的基础数据结构，栈帧用于存储：局部变量表、操作数栈、动态链接、方法出口等，每个方法执行中都对应虚拟机栈帧从入栈到出栈的过程
  - 局部变量表，是一种程序运行数据模型，存放了编译期可知的各种数据类型例如：Boolean、byte、char、short、int、float、long、double、对象引用类型(对象内存地址变量，指针或句柄)，程序运行时，根据局部变量表分配栈帧空间大小，在运行中，大小是不变的
  - 异常类型：
    - stackOverFlowError：线程请求栈深度大于虚拟机允许深度
    - OutOfMemory：内存空间耗尽无法进行扩展
  - 栈帧，一个方法对应一个栈帧内存区域
    - 局部变量表
    - 操作数栈
    - 动态链接，代码存放在方法区中的入口位置是本方法对应的动态链接
    - 方法出口，执行完成本方法后，再继续执行哪段代码的位置
- 本地方法栈
  - 与虚拟机栈类似，虚拟机栈用于JAVA方法的调用，本地方法栈用于本地方法的调用
- 堆
  - 新生代（1）
    - Eden（8）
    - From Survivor（1）
    - To Survivor（1）
  - 老年代（2）
    - 实际运行过程中，最终进入老年代的对象一般为：静态变量引用的对象，线程池对象，对象池，缓存池对象，Spring容器中的Bean等
- 程序计数器
  - 行号指示器，字节码指令的分支、循环、跳转、异常处理、线程恢复(CPU切换)，每条线程都需要一个独立的计数器，线程私有内存互不影响,该区域不会发生内存溢出异常
  - 程序计数器是每个线程的私有空间，JAVA虚拟机会为每个JAVA线程创建程序计数器，任意一个时刻，一个JAVA线程总是在执行一个方法，这个正在执行的方法称为当前方法，如果当前方法不是本地方法，PC寄存器会指向当前正在被执行的指令，如果当前方法是本地方法，那么PC寄存器的值就是undefined
- 直接内存
  - 直接内存不属于虚拟内存区域，是一种基于通道与缓冲区的IO方式，可以使用本地函数直接分配堆外内存，在堆中存储引用的外部内存地址，通过引用完成对直接引用内存的操作，1.4之后提供的NIO显著提高效率，避免了堆内存与Native内存的来回复制操作，不受虚拟机内存控制，会抛出OUtOfMemory异常。
##### 3，垃圾回收
- GC Root根节点
  - minor GC
  - full GC
  - 对象头，分代年龄
  - STW（stop the world）机制
- 常见的问题
  - GC在什么时候触发？
  - minor gc后，对象什么时候直接被移入老年代？
##### 4，常用命令
- 对代码进行反汇编，生成更可读的字节码
```
javap -c XXX.class > XXX.txt
```
##### 5，问题解答
- 成员变量，局部变量，静态变量分别存放在哪？
  - 成员变量：方法外部，类的内部定义的变量
    - 成员变量存储在堆中对象里面，由垃圾回收器负责回收
  - 局部变量：方法或语句块内部定义的变量或者形参
    - 基础数据类型的引用和值都存储在栈中
    - 对象类型的引用存在栈中，对象存在堆中
  - 静态变量：static关键字修饰的变量
    - 静态变量的引用存放在方法区
    - 静态变量实际创建的对象存放在堆中
##### 6，调优策略
- 给应用分配合理的新生代空间，尽量将对象分配到新生代使用minorGC回收，从而减少fullGC的频率
- 堆最大内存和堆最小内存设置相等，来减少GC的次数
- 常量过多或者代理反射等使用频繁会导致OOM异常
- 尽可能减少系统执行垃圾回收的总时间，采用并行垃圾回收器
- 尽量使用CMS回收器并发GC