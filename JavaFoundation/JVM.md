# JVM
##### 1，JVM三个子系统
- 类加载子系统：根据程序运行的需要加载用到的类
- 执行引擎子系统：在JVM种执行字节码指令
- 垃圾收集子系统：自动内存管理
---
##### 2，JVM内存模型
- 方法区
  - 存放：运行时常量池信息，静态变量的引用，类信息
  - 1.8前被称作永久代
  - 1.8及1.8后称为元空间（使用操作系统的直接内存）
- 虚拟机栈（JAVA栈，线程栈）
  - 是线程私有的，声明周期与线程相同，虚拟机栈是Java方法执行的内存模型，每个方法被执行时都会创建一个栈帧，即方法运行期间的基础数据结构，栈帧用于存储：局部变量表、操作数栈、动态链接、方法出口等，每个方法执行中都对应虚拟机栈帧从入栈到出栈的过程
  - 局部变量表，是一种程序运行数据模型，存放了编译期可知的各种数据类型例如：Boolean、byte、char、short、int、float、long、double、对象引用类型(对象内存地址变量，指针或句柄)，程序运行时，根据局部变量表分配栈帧空间大小，在运行中，大小是不变的
  - 异常类型：
    - stackOverFlowError：线程请求栈深度大于虚拟机允许深度
    - OutOfMemory：内存空间耗尽无法进行扩展
  - 栈帧，一个方法对应一个栈帧内存区域
    - 局部变量表
    - 操作数栈
    - 动态链接，代码存放在方法区中的入口位置是本方法对应的动态链接
    - 方法出口，执行完成本方法后，再继续执行哪段代码的位置
- 本地方法栈
  - 与虚拟机栈类似，虚拟机栈用于JAVA方法的调用，本地方法栈用于本地方法的调用
- 堆
  - 新生代（1）
    - Eden（8）
    - From Survivor（1）
    - To Survivor（1）
  - 老年代（2）
    - 实际运行过程中，最终进入老年代的对象一般为：静态变量引用的对象，线程池对象，对象池，缓存池对象，Spring容器中的Bean等
- 程序计数器
  - 行号指示器，字节码指令的分支、循环、跳转、异常处理、线程恢复(CPU切换)，每条线程都需要一个独立的计数器，线程私有内存互不影响,该区域不会发生内存溢出异常
  - 程序计数器是每个线程的私有空间，JAVA虚拟机会为每个JAVA线程创建程序计数器，任意一个时刻，一个JAVA线程总是在执行一个方法，这个正在执行的方法称为当前方法，如果当前方法不是本地方法，PC寄存器会指向当前正在被执行的指令，如果当前方法是本地方法，那么PC寄存器的值就是undefined
- 直接内存
  - 直接内存不属于虚拟内存区域，是一种基于通道与缓冲区的IO方式，可以使用本地函数直接分配堆外内存，在堆中存储引用的外部内存地址，通过引用完成对直接引用内存的操作，1.4之后提供的NIO显著提高效率，避免了堆内存与Native内存的来回复制操作，不受虚拟机内存控制，会抛出OUtOfMemory异常。
---
##### 3，垃圾回收
- 垃圾回收算法
  - 标记清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
    - 缺点：
      - 标记和清除的效率都不高
      - 标记清除后产生大量不连续的内存碎片，碎片太多无法分配足够连续空间，导致不得不触发GC，甚至Stop The World
  - 复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块内存用完了，将还存另外一块上面，然后在把已使用过的内存空间一次清理掉。
    - 缺点：
      - 当对象存活率较高时，复制操作次数多，效率较低
      - 内存缩小了一半，需要额外空间（老年代）做分配担保
  - 标记整理算法：标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所一端移动，然后直接清理掉端边界以外的内存。
  - 分代收集算法：一般是把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。新生代都发现有大批对象死去，选用复制算法。老年代中因为对象存活率高，必须使用“标记-清理”或“标记-整理”算法来进行回收。
- GC Root根节点
  - minor GC
  - full GC
  - 对象头，分代年龄
  - STW（stop the world）机制
- 常见的问题
  - GC在什么时候触发？
  - minor gc后，对象什么时候直接被移入老年代？
---
##### 4，类加载
- 类加载步骤
  - 加载，连接（验证，准备，解析），初始化，使用，卸载
- 类加载器
  - 作用
    - 加载class
    - 确定类的唯一性
  - 分类
    - 启动类加载器
      - 负责加载`JAVA_HOME\lib`目录
      - 被`-Xbootclasspath`参数指定目录中的部分类
        - `System.getProperty(“sun.boot.class.path”)`查看具体哪些类
    - 扩展类加载器
      - 负责加载`JAVA_HOME\ext`目录
      - 被`java.ext.dirs`参数指定目录中的部分类
        - `System.getProperty(“java.ext.dirs”)`查看具体哪些类
    - 应用程序类加载器
      - 负责加载用户类路径（我们通常指定的classpath）上的类
      - 如果没有自定义类加载器，应用程序类加载器就是程序默认的类加载器
    - 自定义类加载器
      - JVM提供的类加载器只能加载指定目录的类（jar和class），如果我们想从其他地方甚至网络上获取class文件，就需要自定义类加载器来实现
      - 自定义类加载器主要都是通过继承ClassLoader或者它的子类来实现，但无论是通过继承ClassLoader还是它的子类，最终自定义类加载器的父加载器都是应用程序类加载器，因为不管调用哪个父类加载器，创建的对象都必须最终调用java.lang.ClassLoader.getSystemClassLoader()作为父加载器，getSystemClassLoader()方法的返回值是sun.misc.Launcher.AppClassLoader即应用程序类加载器。
  - ClassLoader与双亲委派模型
    - 当一个类加载器加载类的时候，如果有父加载器就先尝试让父加载器加载，如果父加载器还有父加载器就一直往上抛，一直把类加载的任务交给启动类加载器，然后启动类加载器如果加载不到类就会抛出ClassNotFoundException异常，之后把类加载的任务往下抛
    - 双亲委派模型的工作过程是，如果一个类加载器收到了类加载的请求，它首先不会加载类，而是把这个请求委派给它上一层的父加载器，每层都如此，所以最终请求会传到启动类加载器，然后从启动类加载器开始尝试加载类，如果加载不到（要加载的类不在当前类加载器的加载范围），就让它的子类尝试加载，每层都是如此。
    - 双亲委派模型的好处：它让Java中的类跟类加载器一样有了“优先级”。前面说到了对于每一个类，都需要由加载它的加载器和这个类本身共同确立这个类在Java虚拟机中的唯一性，比如java.lang.Object类（存放在JAVA_HOMElibt.jar中），如果用户自己写了一个java.lang.Object类并且由自定义类加载器加载，那么在程序中是不是就是两个类？所以双亲委派模型对保证Java稳定运行至关重要
---
##### 5，常用命令
- 对代码进行反汇编，生成更可读的字节码
```
javap -c XXX.class > XXX.txt
```
---
##### 6，问题解答
- 什么是Java虚拟机
  - Java虚拟机是一个可以执行Java字节码的虚拟机进程，Java源文件被编译成能被Java虚拟机执行的字节码文件。
- 成员变量，局部变量，静态变量分别存放在哪？
  - 成员变量：方法外部，类的内部定义的变量
    - 成员变量存储在堆中对象里面，由垃圾回收器负责回收
  - 局部变量：方法或语句块内部定义的变量或者形参
    - 基础数据类型的引用和值都存储在栈中
    - 对象类型的引用存在栈中，对象存在堆中
  - 静态变量：static关键字修饰的变量
    - 静态变量的引用存放在方法区
    - 静态变量实际创建的对象存放在堆中
---
##### 7，JVM性能调优
- 调优目的：使用较小的内存占用来获得较高的吞吐量或较低的延迟
  - 内存占用：程序正常运行需要的内存大小
  - 延迟：由于垃圾收集引起的程序停顿时间
  - 吞吐量：用户程序运行时间占用户程序何垃圾收集占用总时间的比值
- 定位问题
  - 系统运行日志
  - 堆栈错误信息
    - `java.lang.OutOfMemoryError:Java heap space`：堆内存溢出
    - `java.lang.StackOverflowError`：栈溢出
    - `java.lang.OutOfMemoryError:PermGen space`：方法区溢出
  - GC日志
    - 程序启动时使用`-XX:+PrintGCDetails`和`-Xloggc:/data/jvm/gc.log`可以在程序运行时把gc详细过程记录下来
    - 配置`-verbose:gc`参数把gc日志打印在控制台
  - 线程快照
    - 使用`jstack pid`命令可以dump除当前进程中线程的快照信息
  - 堆转储快照
    - 程序启动时使用`-XX:+HeapDumpOnOutOfMemory`和`-XX:HeapDumpPath=/data/jvm/dumpfile.hprof`，当程序发生内存溢出时，将当时的内存快照以文件形式进行转储，事后再分析
- 调优工具
  - 使用jps（JVM process Status）可以查看虚拟机启动的所有进程，执行主类全名，JVM启动参数
  ```
  # 查看JVM启动的所有进程，启动参数
  jsp -l -v
  ```
  - 使用jstat（JVM Statistics Monitoring Tool）监视虚拟机信息（各个区的容量、使用容量、gc时间等信息）
  ```
  # 每500毫秒打印一次Java堆状况，打印10次
  jstat -gc pid 500 10
  ```
  - 使用jmap（Memory Map for Java）查看堆内存信息
  ```
  # 打印出当前堆中所有每个类的实例数量和内存占用
  jmap -histo pid
  # 转储堆内存快照到指定文件
  jmap -dump:format=b,file=/data/jvm/dumpfile_jmap.hprof 3361
  ```
  - 利用jconsole，jvisualvm分析内存信息
- JVM调优经验
  - 给应用分配合理的新生代空间，尽量将对象分配到新生代使用minorGC回收，从而减少fullGC的频率
  - 堆最大内存和堆最小内存设置相等，来减少GC的次数（空闲<40%则扩容，空闲>70%则缩容）
  - 常量过多或者代理反射等使用频繁会导致OOM异常
  - 尽可能减少系统执行垃圾回收的总时间，采用并行垃圾回收器
  - 尽量使用CMS回收器并发GC
    - 并行：多条垃圾回收线程同时操作
    - 并发：垃圾回收线程与用户线程一起操作
  - 编码经验
    - 避免创建过大对象
    - 避免同时加载大量数据，如一次从数据库中取出大量数据，或一次从Excel中读取大量数据，可以分批读取，用完尽快清空引用
    - 当集合中有对象的引用，这些对象使用完之后要尽快把集合中的引用清空，这些无用对象尽快回收避免进入老年代
    - 避免产生死循环，产生死循环后，循环体内可能重复产生大量实例，导致内存空间被迅速占满
    - 尽量避免长时间等待外部资源（数据库、网络、设备资源等）的情况，缩小对象的生命周期，避免进入老年代，如果不能及时返回结果可以适当采用异步处理的方式等
---